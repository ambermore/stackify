{
    "name": "stackify",
    "description": "is just more than promise.",
    "version": "1.0.13",
    "author": {
        "name": "Amber More"
    },
    "keywords": [
        "stackify",
        "promise",
        "async",
        "rest",
        "restful"
    ],
    "license": [{
        "type": "MIT",
        "url": ""
    }],
    "repository": {
        "type": "git",
        "url": "https://github.com/ambermore/stackify"
    },
    "main": "index.js",
    "engines": {
        "node": "*"
    },
    "bugs": {
        "url": "https://github.com/ambermore/stackify/issues"
    },
    "readme": "# stackify.js\n\nFirst stack with FIFO in mind. It provides you simple and effective way to handle asynchronous JavaScript. Till now we are living in Promise Tower to avoid Pyramid of Doom, but still itâ€™s uncomfortable for programmers who are dealing with huge number of rest requests (or same family request which moves too slowly). So I come-up with mine own implementation of promise tower that provides easy way to handle nested callbacks; and while doing so you can specify frequency slab for parallel processing. So now we can go serially, parallelly or any-ly :-). Again it support old-school coding, which runs on conventional modal of Promise Tower; all of this packed in one small .js file. **In short, stackify.js is just more than promise.** \n\n\n###Installation:\n```javascript\n$ npm install stackify\n```\n\nFor client side html\n\n```html\n<script language='JavaScript' src='stackify.js'></script>\n```\n\n###Quick start:\n```javascript\n// Example for definning stackify processor.\nvar stackify_processor = new STACKIFY(function(index, stackify){\n    // Your current processing item, you can use this for your rest function.\n    var item = stackify.item(index);\n    \n    your_rest_function(item, function(output) {\n        // This will ask stackify to run processor against next item.\n        stackify.next(index, output);\n    });\n}, function(index, stackify) {\n    // You can place common code over here, \n    // which needs to be run after processing of each item.\n    // Current reqest object.\n    var current_request = stackify.request(index);\n    \n    // Current request output if any.\n    var output = current_request.output;\n    // Current request error if any.\n    var error = current_request.error;\n}, function(index, stackify) {\n    // Your last code of execution.\n});\n\n// Now run this processor with any number of item collection.\nstackify_processor.process({\n    'items': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], \n    // Here we can consider number of items equals to number of requests. \n    'slab': 3 \n    // This specifies frequency for parallel processing.\n});\n\n```\n\nAbove request processor can be use with different item collection any where else.\n```javascript\n// We will run this processor with different item collection.\nstackify_processor.process({\n    'items': [{\n        'id': 1,\n        'name': 'Jack Jefferson',\n        'gender': 'male'\n    }, {\n        'id': 2,\n        'name': 'Molly Hooper',\n        'gender': 'female'\n    }], \n    'other_data': {\n        \n    },\n    'headers': {\n        \n    }\n    // Here we specified other optional data, that we can use in our processor.\n    // If we will not specify slab it will parallelly process all items. \n    // Quick hack: For same we can spcify slab as 0.\n});\n```\n\nTo use optional parameters or data, we need to do little change in our processor.\n```javascript\n// So our change procesor will be as\nvar stackify_processor = new STACKIFY(function(index, stackify){\n    // Your current processing item, you can use this for your rest function.\n    var item = stackify.item(index);\n    \n    // This will gives us other_data.\n    var other_data = stackify.options.other_data;\n    \n    // This will gives us headers.\n    var headers = stackify.options.headers;\n    \n    // This will gives us collection of items.\n    var all_items = stackify.options.items;\n    \n    // So, we can also find our current item from items collection as\n    item = stackify.options.items[index];\n    \n    your_rest_function(item, function(output) {\n        // This will ask stackify to run processor against next item.\n        stackify.next(index, output);\n    });\n}, function(index, stackify) {\n    // You can place common code over here, \n    // which needs to be run after processing of each item.\n    // So, we can find current request also from requests collection.\n    var current_request = stackify.requests[index];\n    \n}, function(index, stackify) {\n    // Your last code of execution.\n    // So we can have all requests` ouput or error at last by\n    var requests = stackify.requests;\n});\n```\n\nNow, how we can specify our nested processor?\n```javascript\n// This will be our nested processor.\nvar stackify_child_processor = new STACKIFY(function(index, stackify){\n    // Your current processing item, you can use this for your rest function.\n    var item = stackify.item(index);\n\n    your_rest_function(item, function(output) {\n        // This will ask stackify to run processor against next item.\n        stackify.next(index, output);\n    });\n}, function(index, stackify) {\n\n}, function(index, stackify) {\n    // On completion we will execute next method of parent.\n    stackify.parent.next(stackify.parent.index, stackify.requests);\n}, 'stackify_child_processor');\n// Now here we specified processor name 'stackify_child_processor', this is optional.\n\n// So our change procesor will be as\nvar stackify_parent_processor = new STACKIFY(function(index, stackify){\n    // Your current processing item, you can use this for your rest function.\n    var item = stackify.item(index);\n    // Current processor name.\n    var name = stackify.name;\n\n    your_rest_function(item, function(output) {\n        // This will ask stackify to run child processor.\n        stackify_child_processor.process({\n            'items': output\n            // Here we have consider 'output' is array.\n        }, stackify);\n        \n        // No next is required for this, \n        // we will call next of this processor from child.\n    });\n}, function(index, stackify) {\n    // Now, in this case we will have actual use of this method.\n    // Since, we can not write our common execution code in rest callback.\n}, function(index, stackify) {\n    // Your last code of execution.\n    // So we can have all requests` ouput or error at last by\n    var requests = stackify.requests;\n}, 'stackify_parent_processor');\n```\n\n###Conventional Promise:\nHow we can support our old code, we can do this by-\n```javascript\n(new STACKIFY()).then(function(value) {\n    console.log(new Date());\n    // This will be forward to next then method.\n    return 10;\n}).then(function(value) {\n        console.log(new Date());\n    console.log('Earlier request output: ', value);\n        return value + 20;\n}).then(function(value) {\n    console.log(new Date());\n    console.log('Earlier request output: ', value);\n    return value + 30;\n}).catch(function(requests) {\n    // In case of any error, this will get executed.\n}).done(function(requests) {\n        // This will get executed at last.\n});\n```\n\nFor handling our rest callback, we need to pass options to STACKIFY constuctor.\n```javascript\n// Here we are passing require_next as 'true'.\n(new STACKIFY({\n    'require_next': true,\n    'on_error_stop': true\n    // In case of any error, instantly it will halt our next step execution.\n})).then(function(value, next) {\n    console.log(new Date());\n    // This will be forward to next then method.\n        next(10);\n}).then(function(value, next) {\n        console.log(new Date());\n    console.log('Earlier request output: ', value);\n        next(20);\n}).then(function(value, next) {\n    console.log(new Date());\n    console.log('Earlier request output: ', value);\n\n    your_rest_function(value, function(output) {\n        next(output);\n    });\n}).catch(function(requests, halt_execution_at) {\n    // In case of any error, this will get executed.\n    // 'halt_execution_at' will give us index at which exceution got halt.\n    console.log('Execution halt at: ', halt_execution_at);\n    console.log('Error: ', requests[halt_execution_at].error);\n}).done(function(requests) {\n        // This will get executed at last.\n});\n```\n\nWe can also pass collection of methods to our processor by .all method.\n```javascript\n// This can be handle by passing option require_next as 'true'.\n(new STACKIFY()).all([function(value) {\n    console.log(new Date());\n    // This will be forward to next then method.\n        return 10;\n}, function(value) {\n        console.log(new Date());\n    console.log('Earlier request output: ', value);\n        return value + 20;\n}, function(value) {\n    console.log(new Date());\n    console.log('Earlier request output: ', value);\n    return value + 30;\n}).catch(function(requests, halt_execution_at) {\n    // In case of any error, this will get executed.\n    // 'halt_execution_at' will give us index at which exceution got halt.\n}).done(function(requests) {\n        // This will get executed at last.\n});\n\n// Quick hack: With this, we can also use 'require_next' and other options.\n```\n\nAgain, if we need to delay our next execution we can do that with .delay method.\n```javascript\n(new STACKIFY()).then(function(value) {\n    console.log(new Date());\n    // This will be forward to next then method.\n        return 10;\n})\n// This will delay next execution for 10 seconds.\n.delay(10000).then(function(value) {\n        console.log(new Date());\n    console.log('Earlier request output: ', value);\n        return value + 20;\n}).then(function(value) {\n    console.log(new Date());\n    console.log('Earlier request output: ', value);\n    return value + 30;\n}).catch(function(requests, halt_execution_at) {\n    // In case of any error, this will get executed.\n    // 'halt_execution_at' will give us index at which exceution got halt.\n}).done(function(requests) {\n        // This will get executed at last.\n});\n```\n\n####Till now thats all, Thanks Folks!\n\n\n###License\nCopyright 2014, Amber More MIT License (enclosed)",
    "readmeFilename": "README.md",
    "_id": "stackify@1.0.1",
    "_from": "stackify@"
}